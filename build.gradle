plugins {
    id 'eclipse'
}

task cleantmp {
    doFirst {
        def commonfolder = file('./build/tmp/common')
        if(commonfolder.exists()) {
            delete commonfolder
        }
        gradle.ext.mcversions.each {
            def folder = file('./build/tmp/' + it)
            if(folder.exists()) {
                delete folder
            }
            def fabrictmp = file('./build/tmp/fabric' + it)
            if(fabrictmp.exists()) {
                delete fabrictmp
            }
            def forgetmp = file('./build/tmp/forge' + it)
            if(forgetmp.exists()) {
                delete forgetmp
            }
            def neoforgetmp = file('./build/tmp/neoforge' + it)
            if(neoforgetmp.exists()) {
                delete neoforgetmp
            }
        }
    }
}

task unpackjars {
    dependsOn ':cleantmp'
    dependsOn ':common:build'
    gradle.ext.mcversions.each {
        dependsOn ':fabric' + it + ':build'
        dependsOn ':forge' + it + ':build'
        if(it >= '1.21') {
            dependsOn ':neoforge' + it + ':build'
        }
    }
    
    def commonfolder = file('./build/tmp/common')
    
    doFirst {
        copy {
            from fileTree('./common/resources')
            into commonfolder
        }
        copy {
            from zipTree('./common/build/libs/common.jar')
            into commonfolder
        }
        
        gradle.ext.mcversions.each {
            def mcversion = it
            def folder = file('./build/tmp/' + mcversion)
            file(folder.absolutePath + '/META-INF').mkdirs()
            
            def manifest = file('./build/tmp/' + mcversion + '/META-INF/MANIFEST.MF')
            manifest.text = 'Manifest-Version: 1.0'
            
            def fabrictmp = file('./build/tmp/fabric' + mcversion)
            copy {
                from zipTree('./fabric' + mcversion + '/build/libs/' + gradle.ext.fabricname + '-' + gradle.ext.modversion + '.jar')
                into fabrictmp
            }
            fileTree(fabrictmp).each {
                def relpath = it.absolutePath.substring(fabrictmp.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath == '/META-INF/MANIFEST.MF') {
                    it.text.eachLine {
                        if(it.size() > 0 && !it.startsWith('Manifest-Version:')) {
                            manifest.text += ('\n' + it)
                        }
                    }
                }else if(!target.exists()){
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
            
            def forgetmp = file('./build/tmp/forge' + mcversion)
            copy {
                from zipTree('./forge' + mcversion + '/build/libs/' + gradle.ext.forgename + '-' + gradle.ext.modversion + '.jar')
                into forgetmp
            }
            // Temporary manual copy until I can get rid of Mixin
            if(mcversion >= '1.21.3') {
                copy {
                    from file('./forge' + mcversion + '/build/tmp/compileJava')
                    include 'mixins.buildguide.forge.refmap.json'
                    into forgetmp
                }
            }
            fileTree(forgetmp).each {
                def relpath = it.absolutePath.substring(forgetmp.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath == '/META-INF/MANIFEST.MF') {
                    it.text.eachLine {
                        if(it.size() > 0 && !it.startsWith('Manifest-Version:')) {
                            manifest.text += ('\n' + it)
                        }
                    }
                }else if(!target.exists()){
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
            
            if(mcversion >= '1.21') {
                def neoforgetmp = file('./build/tmp/neoforge' + mcversion)
                copy {
                    from zipTree('./neoforge' + mcversion + '/build/libs/' + gradle.ext.neoforgename + '-' + gradle.ext.modversion + '.jar')
                    into neoforgetmp
                }
                fileTree(neoforgetmp).each {
                    def relpath = it.absolutePath.substring(neoforgetmp.absolutePath.length())
                    def target = file(folder.absolutePath + relpath)
                    //if(relpath == '/META-INF/MANIFEST.MF') {
                    //    it.text.eachLine {
                    //        if(it.size() > 0 && !it.startsWith('Manifest-Version:')) {
                    //            manifest.text += ('\n' + it)
                    //        }
                    //    }
                    //}else
                    if(!target.exists()){
                        def source = it
                        def targetParent = target.getParentFile()
                        targetParent.mkdirs()
                        copy {
                            from source
                            into targetParent
                        }
                    }
                }
            }
            
            manifest.text += '\n\n'
        }
    }
    
    doLast {
        delete commonfolder.absolutePath + '/META-INF'
        
        gradle.ext.mcversions.each {
            def folder = file('./build/tmp/' + it)
            fileTree(commonfolder).each {
                def relpath = it.absolutePath.substring(commonfolder.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath != '\\META-INF\\MANIFEST.MF' && !target.exists()) {
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
        }
    }
}

gradle.ext.mcversions.each {
    def mcversion = it
    task "zip$it"(type: Zip, dependsOn: "unpackjars") {
        dependsOn ':unpackjars'
        from fileTree('./build/tmp/' + mcversion)
        archiveFileName = rootProject.name + "-" + mcversion + "-" + gradle.ext.modversion + ".jar"
        destinationDirectory = file('./build/libs')
    }
}

task build {
    gradle.ext.mcversions.each {
        dependsOn tasks.getByName("zip$it")
    }
}

configure(subprojects.findAll {it.name != 'common'}) {
    apply plugin: 'java'
    apply plugin: 'eclipse'
    dependencies {
        implementation project(":common")
    }
    if(it.name < 'forge1.20.4' || !it.name.startsWith('forge')) {
        sourceSets.main.java {
            srcDir '../common/src'
        }
    }
    sourceSets.main.resources {
        srcDir '../common/resources'
    }
    eclipse {
        classpath {
            file {
                whenMerged { classpath ->
                    classpath.entries.findAll{ it.kind == 'src' && it.hasProperty("dir") && (it.dir.toString().endsWith("\\common\\src") || it.dir.toString().endsWith("\\common\\resources")) }.each {
                        classpath.entries.remove(it)
                    }
                    classpath.entries.findAll{ it.kind == 'src' && it.hasProperty("path") && (it.path.toString().equals("common-resources") || it.path.toString().equals("src"))}.each {
                        classpath.entries.remove(it)
                    }
                    classpath.entries.findAll{ it.kind == 'src' && it.hasProperty("path") && it.path.toString().endsWith("modMetadata") }.each {
                        classpath.entries.remove(it)
                    }
                }
            }
        }
        project.file.withXml {
            def res = it.asNode().get('linkedResources')[0]
            res.link.findAll{ it.location[0].text().endsWith('/common/src') || it.location[0].text().endsWith('/common/resources') }.each {
                res.remove(it)
            }
        }
    }
}